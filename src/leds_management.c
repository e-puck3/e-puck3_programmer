/**
 * @file	leds_management.c
 * @brief  	Functions to control the states of the leds. It is the module used to control the leds.
 * 			If one tries to set a led outside of this module, it will probably not work as intended, as
 * 			this module updates the states of the leds.
 * 			Reads the events generated by the other modules in order to decide what to do with the leds
 * 
 * @written by  	Eliot Ferragni
 * @creation date	10.06.2020
 */

#include "leds_management.h"
#include "power_button.h"
#include "voltage_measurement.h"
#include "communications.h"
#include "leds.h"
#include "gdb.h"

//values used to control the Red, Green and Blue leds
//Default values
static uint16_t leds_values[NB_RGB_LEDS][NB_LEDS] = {	//    RED				GREEN				BLUE
														{LED_NO_POWER, 		LED_QUARTER_POWER, 	LED_MAX_POWER},
														{LED_NO_POWER, 		LED_NO_POWER, 		LED_NO_POWER},
														{LED_QUARTER_POWER, LED_NO_POWER, 		LED_NO_POWER}};

#define POWER_EVENT 			EVENT_MASK(0)
#define VBUS_INFO_EVENT 		EVENT_MASK(1)
#define BATTERY_INFO_EVENT		EVENT_MASK(2)
#define GDB_STATUS_EVENT 		EVENT_MASK(3)
#define COMMUNICATIONS_EVENT 	EVENT_MASK(4)

/////////////////////////////////////////PRIVATE FUNCTIONS/////////////////////////////////////////

static THD_WORKING_AREA(leds_management_thd_wa, 1024);
static THD_FUNCTION(leds_management_thd, arg)
{
	(void) arg;

	chRegSetThreadName("RGB leds management");

	uint8_t running_state = false;
	uint8_t communicating_state = false;
	uint8_t low_power_state = false;

	systime_t time_thread = 0;
	systime_t time_run = 0;
	systime_t time_low_power = 0;
	systime_t time_communication = 0;

	eventmask_t events;
	eventflags_t flags;

	event_listener_t vbus_info_event_listener;
	event_listener_t battery_info_event_listener;
	event_listener_t power_event_listener;
	event_listener_t gdb_status_event_listener;
	event_listener_t communications_event_listener;

	chEvtRegisterMask(&vbus_info_event, &vbus_info_event_listener, VBUS_INFO_EVENT);
	chEvtRegisterMask(&battery_info_event, &battery_info_event_listener, BATTERY_INFO_EVENT);
	chEvtRegisterMask(&power_event, &power_event_listener, POWER_EVENT);
	chEvtRegisterMask(&gdb_status_event, &gdb_status_event_listener, GDB_STATUS_EVENT);
	chEvtRegisterMask(&communications_event, &communications_event_listener, COMMUNICATIONS_EVENT);

	while (true) {

		time_thread = chVTGetSystemTime();
						//////////EVENTS/////////

		events = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
		//power events come from the power_button module
		//the leds near the power button is STATUS_LED1
		if (events & POWER_EVENT) {
			flags = chEvtGetAndClearFlags(&power_event_listener);
			//turns on the leds
			if(flags & POWER_ON_FLAG){
				setLed(STATUS_LED1, RED_LED, leds_values[STATUS_LED1][RED_LED]);
				setLed(STATUS_LED1, GREEN_LED, leds_values[STATUS_LED1][GREEN_LED]);
			}
			//turns off the leds
			else if(flags & POWER_OFF_FLAG){
				setLed(STATUS_LED1, RED_LED, LED_NO_POWER); 
				setLed(STATUS_LED1, GREEN_LED, LED_NO_POWER);
			}
		//battery vents come from the voltage_measurement module
		}else if(events & BATTERY_INFO_EVENT){
			flags = chEvtGetAndClearFlags(&battery_info_event_listener);
			if(flags & BATT_MIN_VOLTAGE_FLAG){
				//red blinking
				low_power_state = true;
				leds_values[STATUS_LED1][RED_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED1][GREEN_LED] = LED_NO_POWER;
			}else if(flags & BATT_VERY_LOW_VOLTAGE_FLAG){
				//red
				low_power_state = false;
				leds_values[STATUS_LED1][RED_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED1][GREEN_LED] = LED_NO_POWER;
			}else if(flags & BATT_LOW_VOLTAGE_FLAG){
				//orange
				low_power_state = false;
				leds_values[STATUS_LED1][RED_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED1][GREEN_LED] = LED_MIN_POWER;
			}else if(flags & BATT_GOOD_VOLTAGE_FLAG){
				//yellow
				low_power_state = false;
				leds_values[STATUS_LED1][RED_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED1][GREEN_LED] = LED_QUARTER_POWER;
			}else if(flags & BATT_MAX_VOLTAGE_FLAG){
				//green
				low_power_state = false;
				leds_values[STATUS_LED1][RED_LED] = LED_NO_POWER;
				leds_values[STATUS_LED1][GREEN_LED] = LED_QUARTER_POWER;
			}

			//updates the leds if the robot is ON if it is not blinking
			if(powerButtonGetPowerState() == POWER_ON && !low_power_state){
				setLed(STATUS_LED1, RED_LED, leds_values[STATUS_LED1][RED_LED]);
				setLed(STATUS_LED1, GREEN_LED, leds_values[STATUS_LED1][GREEN_LED]);
			}
		}
		//gdb status events come from gdb_main
		//the led for gdb is near the center of the board and is STATUS_LED3
		else if(events & GDB_STATUS_EVENT){
			flags = chEvtGetAndClearFlags(&gdb_status_event_listener);
			//during IDLE, we simply have the green led ON and others OFF
			if(flags & IDLE_FLAG){
				running_state = false;
				setLed(STATUS_LED3, RED_LED, LED_NO_POWER);
				setLed(STATUS_LED3, GREEN_LED, leds_values[STATUS_LED3][GREEN_LED]);
			}
			//during running state, we make the leds blink
			else if(flags & RUNNING_FLAG){
				running_state = true;
				setLed(STATUS_LED3, RED_LED, LED_NO_POWER);
			}
			//during the programming state, we make the red led blink at each flashwrite
			else if(flags & PROGRAMMING_FLAG){
				//flag set when we are programming the target.
				//since it is called at every flash write order, we need to blink the leds here
				toggleLed(STATUS_LED3, RED_LED, leds_values[STATUS_LED3][RED_LED]);
			}
			//does nothing for now
			if(flags & ERROR_FLAG){
			}
		}
		//communications events come from communications and aseba_bridge
		//the led near the USB connector is STATUS_LED2
		else if(events & COMMUNICATIONS_EVENT){
			flags = chEvtGetAndClearFlags(&communications_event_listener);

			//a communications is active
			if(flags & ACTIVE_COMMUNICATION_FLAG){
				communicating_state = true;
			}
			//no more communications
			else if(flags & NO_COMMUNICATION_FLAG){
				communicating_state = false;
			}
		}
		//vbus events come from the voltage_measurement module
		else if(events & VBUS_INFO_EVENT){
			flags = chEvtGetAndClearFlags(&vbus_info_event_listener);
			// leds OFF
			if(flags & VBUS_NO_VOLTAGE_FLAG){
				leds_values[STATUS_LED2][RED_LED] = LED_NO_POWER;
				leds_values[STATUS_LED2][GREEN_LED] = LED_NO_POWER;
				leds_values[STATUS_LED2][BLUE_LED] = LED_NO_POWER;
			}
			// orange
			else if(flags & VBUS_DEFAULT_VOLTAGE_FLAG){
				leds_values[STATUS_LED2][RED_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED2][GREEN_LED] = LED_MIN_POWER;
				leds_values[STATUS_LED2][BLUE_LED] = LED_NO_POWER;
			}
			// yellow
			else if(flags & VBUS_FIRST_STEP_FLAG){
				leds_values[STATUS_LED2][RED_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED2][GREEN_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED2][BLUE_LED] = LED_NO_POWER;
			}
			// green
			else if(flags & VBUS_SECOND_STEP_FLAG){
				leds_values[STATUS_LED2][RED_LED] = LED_NO_POWER;
				leds_values[STATUS_LED2][GREEN_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED2][BLUE_LED] = LED_NO_POWER;	
			}
			// light blue
			else if(flags & VBUS_THIRD_STEP_FLAG){
				leds_values[STATUS_LED2][RED_LED] = LED_NO_POWER;
				leds_values[STATUS_LED2][GREEN_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED2][BLUE_LED] = LED_QUARTER_POWER;	
			}
			// purple
			else if(flags & VBUS_HIGHEST_VOLTAGE_FLAG){
				leds_values[STATUS_LED2][RED_LED] = LED_QUARTER_POWER;
				leds_values[STATUS_LED2][GREEN_LED] = LED_NO_POWER;
				leds_values[STATUS_LED2][BLUE_LED] = LED_QUARTER_POWER;	
			}

			//updates the leds if the robot is ON if it is not blinking
			if(powerButtonGetPowerState() == POWER_ON && !communicating_state){
				setLed(STATUS_LED2, RED_LED, leds_values[STATUS_LED2][RED_LED]);
				setLed(STATUS_LED2, GREEN_LED, leds_values[STATUS_LED2][GREEN_LED]);
				setLed(STATUS_LED2, BLUE_LED, leds_values[STATUS_LED2][BLUE_LED]);
			}

		}

/////////////////////                 BLINKING PART                /////////////////////

								///////POWER LED////////

		//condition to blink the green led at the specified frequency when the target is in low power mode
		if(low_power_state && (powerButtonGetPowerState() == POWER_ON)){
			if(time_low_power < chVTGetSystemTime()){
				time_low_power = chVTGetSystemTime() + TIME_MS2I(BLINK_TIME);
				toggleLed(STATUS_LED1, RED_LED, leds_values[STATUS_LED1][RED_LED]);
				toggleLed(STATUS_LED1, GREEN_LED, leds_values[STATUS_LED1][GREEN_LED]);
				toggleLed(STATUS_LED1, BLUE_LED, leds_values[STATUS_LED1][BLUE_LED]);
			}
		}


								///////GDB LED////////

		//condition to blink the green led at the specified frequency when the target is in run mode
		if(running_state && (powerButtonGetPowerState() == POWER_ON)){
			if(time_run < chVTGetSystemTime()){
				time_run = chVTGetSystemTime() + TIME_MS2I(BLINK_TIME);
				toggleLed(STATUS_LED3, GREEN_LED,leds_values[STATUS_LED3][GREEN_LED]);
			}
		}

								////////USB_LED///////////

		//condition to blink the usb led at the specified frequency when a communication is active
		if(communicating_state && (powerButtonGetPowerState() == POWER_ON)){
			if(time_communication < chVTGetSystemTime()){
				time_communication = chVTGetSystemTime() + TIME_MS2I(COMMUNICATION_BLINK_TIME);
				toggleLed(STATUS_LED2, RED_LED, leds_values[STATUS_LED2][RED_LED]);
				toggleLed(STATUS_LED2, GREEN_LED, leds_values[STATUS_LED2][GREEN_LED]);
				toggleLed(STATUS_LED2, BLUE_LED, leds_values[STATUS_LED2][BLUE_LED]);
			}
		}
		//we put restore the led state after COMMUNICATION_BLINK_TIME if no more active communication
		else{
			if(time_communication < chVTGetSystemTime()){
				setLed(STATUS_LED2, RED_LED, leds_values[STATUS_LED2][RED_LED]);
				setLed(STATUS_LED2, GREEN_LED, leds_values[STATUS_LED2][GREEN_LED]);
				setLed(STATUS_LED2, BLUE_LED, leds_values[STATUS_LED2][BLUE_LED]);
			}
		}

		chThdSleepUntilWindowed(time_thread, time_thread + TIME_MS2I(10));
	}
}

//////////////////////////////////////////PUBLIC FUNCTIONS/////////////////////////////////////////

void ledsManagementStart(void){

	/*
	 *	Starts the PWM managing the leds
	 */
	ledsInit();

	/*
	 * Starts the leds states thread
	 */
	chThdCreateStatic(leds_management_thd_wa, sizeof(leds_management_thd_wa), NORMALPRIO, leds_management_thd, NULL);
}

